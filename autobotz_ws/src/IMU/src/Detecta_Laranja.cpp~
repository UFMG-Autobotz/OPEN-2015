#include "funcao.h"

//----------------------------DECLARAÇÃO DE VARIÁVEIS---------------------------------------

Point center;//Variável que guarda o valor das coordenadas do centro do objeto identificado
int distancia;//Guarda um número que representa se o objeto alvo(bolinha laranja) está distante da tela ou não.
Rect r;

//-------------------------------------------------------------------------------------------

char* itoa(int value, char* result, int base){// Essa função foi utilizada para converter uma variável inteira(int) para outra do tipo vetor de char(string). Para mais informações acesse a seção "char* version 0.4" no site: http://www.jb.man.ac.uk/~slowe/cpp/itoa.html
	if(base < 2 || base > 36){ 
		*result = '\0'; 
		return result; 
	} 
	char* ptr = result, *ptr1 = result, tmp_char;
	int tmp_value;
	do{
		tmp_value = value;
		value /= base;
		*ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
	}while (value);
	if (tmp_value < 0) *ptr++ = '-';
		*ptr-- = '\0';
	while(ptr1 < ptr){
		tmp_char = *ptr;
		*ptr--= *ptr1;
		*ptr1++ = tmp_char;
	}
	return result;
}

//-------------------------------------------------------------------------------------------

void Laranja(){
	Mat binary;
	inRange(image_HSV, Scalar(0, 135, 165), Scalar(174, 255, 255), binary);//Conseguindo a imagem binária 
	int i;
	vector< vector<Point> > contours;
	findContours(binary, contours, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE);//Encontra contornos 
	vector<double> areas(contours.size());
	for(i = 0; i < contours.size(); i++){ //Encontra a área de maior contorno
		areas[i] = contourArea(Mat(contours[i]));
	}
	double max;
	Point maxPosition;
	minMaxLoc(Mat(areas),0,&max,0,&maxPosition);
	drawContours(binary, contours, maxPosition.y, Scalar(255), CV_FILLED);//Desenha o maior contorno
	if(contours.size() >= 1){
		r = boundingRect(contours[maxPosition.y]);
		rectangle(image_rgb, r.tl(),r.br(), CV_RGB(255, 0, 0), 3, 8, 0);//Desenha um retângulo sobre a área com mair contorno
	}
	center.x = r.x + (r.width/2);//Calcula a coordenda X do centro usando a largura(r.width) do retângulo desenhado.
	center.y= r.y + (r.height/2);//Calcula a coordenda Y do centro usando a altura(r.height) do retângulo desenhado.
	char x[15],y[6];
	itoa(center.x,x,10);//Converte as coordenadas X e Y do centro de inteiro para string.
	itoa(center.y,y,10);
	strcat(x," , ");//Separa o valor da variável X do valor de Y através de uma vírgula(",");
	putText(image_rgb, strcat(x,y), center, FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(255,0,0), 1, CV_AA);//Coloca o valor das coordenas do centro da bolinha na "imagem_rgb", no centro(center) da imagem e determina a fonte e tamanho da letra.
	string textDireita = "Bolinha na direita !";
	string textEsquerda = "Bolinha na esquerda !";
	string textCentro = "Bolinha no centro !";
	int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;//Define a fonte que será usada.
	double fontScale = 1;//Define o tamanho da letra.
	int thickness = 3;
	cv::Point textOrg(10, 130);//Define em qual coordenada de pixels o texto começará, ou seja, o posicionamento do texto na tela.

	if(center.x < 295)//Caso o objeto de interesse esteja a esquerda da tela, ou seja, em um pixel inferior a 265, então escreverá na tela "Bolinha na esquerda !"
		cv::putText(image_rgb, textEsquerda, textOrg, fontFace, fontScale, Scalar::all(255), thickness,8);//Coloca na "imagem_rgb" um texto que indica em qual das três faixas de tela a bolinha se encontra.

	else if(center.x > 345)//Caso o objeto de interesse esteja a direita da tela, ou seja, em um pixel superior a 365, então escreverá na tela "Bolinha na direita !".
		cv::putText(image_rgb, textDireita, textOrg, fontFace, fontScale, Scalar::all(255), thickness,8);

	else if(center.x >= 295 && center.x <= 345)//Caso o objeto de interesse esteja no meio  da tela, ou seja, em um pixel inferior a 365 e superior a 265, então escreverá na tela "Bolinha no centro!".
		cv::putText(image_rgb, textCentro, textOrg, fontFace, fontScale, Scalar::all(255), thickness,8);
	imshow("Final",image_rgb);
}

void GetDistance(){//Essa função retorna um número que representa se o objeto alvo(bolinha laranja) está distante da tela ou não.
	char w[15],h[6];
	itoa(r.width,w,10);//Converte o tipo da variável que guarda a largura do retângulo de "int" para "string".
	itoa(r.height,h,10);//Converte o tipo da variável que guarda a altura do retângulo de "int" para "string".
	strcat(w," , ");//Separa o valor de cada variável através de uma vírgula(",");
	cv::Point textOrgW(100, 200);//Define em qual coordenada de pixels o texto começará, ou seja, o posicionamento do texto na tela.
	putText(image_rgb, strcat(w,h), textOrgW, FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(255,0,0), 1, CV_AA);//Coloca o valor da largura e altura do retângulo na "imagem_rgb".
	if(r.width > 80 && r.width < 120){//Caso a largura do retângulo desenhado esteja nessa faixa, então a bolinha laranja estará próxima da tela. Logo, a variável "distância" recebe o número 1.  
		distancia = 1;
	}
	
	if(r.width >= 120){//Caso a largura do retângulo desenhado esteja nessa faixa, então a bolinha laranja estará MUITO próxima da tela. Logo, a variável "distância" recebe o número 2.
		distancia = 2;
	}

	if(r.width > 0 && r.width <= 80){//Caso a largura do retângulo desenhado esteja nessa faixa, então a bolinha laranja estará longe da tela. Logo, a variável "distância" recebe o número 3.
		distancia = 3;
	}


}

//-------------------------------------------------------------------------------------------

void imageCallback(const sensor_msgs::ImageConstPtr& image){//Essa função é chamada toda vez que uma nova imagem for publicada pelo kinect.
	cv_bridge::CvImageConstPtr cv_ptr;//"cv_bridge" é usado para converter imagens no ROS para imagens no OpenCV, cujo formato é do tipo "cv::Mat".
	try{
		cv_ptr = cv_bridge::toCvShare(image, "bgr8");
	} 
	catch(cv_bridge::Exception& e){
		ROS_ERROR("cv_bridge exception: %s", e.what());
		return;
	} 	
	image_rgb = cv_ptr->image;//Iguala "image_rgb" às imagens que estão sendo obtidas na câmera(cv_ptr->image).
	//namedWindow("Original Image"); //Define a janela
	//imshow("Original Image", image_rgb); //Mostra a imagem original obtida pelo kinect.
	RGBtoHSV();
	Laranja();
}



