//Bibliotecas do ROS

#include <ros/ros.h>	
#include <image_transport/image_transport.h> // Inclui tudo que é necessário para publicar e subscrever uma imagem
#include <cv_bridge/cv_bridge.h>	
#include <sensor_msgs/image_encodings.h>
#include <sensor_msgs/Image.h>
#include <std_msgs/UInt16.h>
#include "std_msgs/String.h"

//Bibliotecas do OpenCV	
#include <opencv2/imgproc/imgproc.hpp>	
#include <opencv2/highgui/highgui.hpp>
#include "opencv2/core/core.hpp"	
#include <opencv2/opencv.hpp>
#include "opencv/cvaux.h"
#include "opencv/highgui.h"
#include "opencv/cxcore.h"
#include <opencv/cv.h>
#include <highgui.h>
#include <cxcore.h>
#include <cv.h> 

//Bibliotecas do C++
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>  
#include <string.h> 
#include <iostream> 
#include <sstream>

// Define os símbolos de pré-processamento XK_MISCELLANY, XK_LATIN1, XK_LATIN2, XK_LATIN3, XK_LATIN4 e XK_GREEK e, em seguida, inclui <X11 / keysymdef.h>
#include <X11/keysym.h> 

//Diretório que contém o arquivo "Num.msg" que especifica o tipo de uma mensagem
#include "beginner_tutorials/Num.h"

/*
Quando chamamos "using namespace<alguma_namespace>" então todos os símbolos dessa namespace se tornarão visíveis, ou seja, não será necessário colocar o prefixo da namespace utilizada. Se usarmos, por exemplo, "using namespace std" poderemos escrever apenas "cout" em vez de std::cout, pois "cout" é um operador definido pela "namespace std".
*/

using namespace cv;
using namespace std;

ros::Publisher pub2;//"pub2" será usado abaixo para publicar em um tópico sem ser necessário usar o prefixo "ros::Publisher" todas as vezes que for usado.

static const char WINDOW[] = "Image Processed";	//Declaração de uma string com o nome da janela que será criada, onde as imagens processadas serão exibidas.

Mat image_rgb, image_depth, H, S, V , image_HSV; /* "image_rgb" é a imagem obtida pelo kinect. "H", "S", "V" são as três componentes da "image_HSV" que serão usadas no método "morphOps()" para retirar o ruído da imagem. Image_HSV é a image_rgb convertida pelo método RGBtoHSV */

int coordenada;//Variável que guarda o valor da coordenada X do objeto identificado

Mat HThresholded, SThresholded, VThresholded;

//Valores máximos e mínimos de cada parte da imagem HSV(Hue, saturation e value). Os valores colocados permitem detectar a cor LARANJA. Caso seja do interesse identificar outra cor, basta passar os valores H, S, V mínimos e máximos da cor desejada. Esses valores podem ser facilmente encontrados na "web".
int H_min;
int H_max;
int V_min;
int V_max;
int S_min; 
int S_max;


typedef union U_FloatParse {
    float float_data;
    unsigned char byte_data[4];
} U_FloatConvert;

const int MIN_IDENT = 50;
const int MAX_RAD_DIFF = 10;
const int HISTORY_SIZE = 5;
const int X_THRESH = 15;
const int Y_THRESH = 15;
const int R_THRESH = 20;
const int MATCHES_THRESH = 3;
const int HUE_BINS = 32;

int depth;

Point center;

/* "image_transport" é uma facilidade do ROS com a qual podemos subscrever uma série de imagens que são transmitidas em um formato compactado, e acessar essas mensagens em um formato não compactado, sem se preocupar com os detalhes da compressão e descompressão em nosso código.

"image_transport publishers" são utilizados como "ROS Publishers", mas oferecem uma variedade de opções de transmissão especializados (compressão JPEG, streaming de vídeo, etc.). Diferentes "subscribers" podem solicitar as imagens do mesmo "publisher", utilizando diferentes meios para transmití-la.
Diferente do "ROS Publishers" que publica em um único tópico, "image_transport" publica em tantos tópicos quanto for a quantidade de imagens transmitidas disponíveis. 

"image_transport subscribers" são usados como "ros::Subscriber", mas são mais especializados em receber imagens.
 
Mais informações podem ser obtidas em http://wiki.ros.org/image_transport e em http://library.isr.ist.utl.pt/docs/roswiki/image_transport.html */

image_transport::Publisher pub; 

void morphOps(Mat &thresh){// Essa função passa os filtros "erode" e "dilate" na imagem para retirar os possíveis ruídos que nela estiverem. 
 	Mat erodeElement = getStructuringElement( MORPH_RECT,Size(3,3));	
 	Mat dilateElement = getStructuringElement( MORPH_RECT,Size(8,8));
        erode(thresh,thresh,erodeElement);
        erode(thresh,thresh,erodeElement);
        dilate(thresh,thresh,dilateElement);
        dilate(thresh,thresh,dilateElement);
}

void RGBtoHSV(){//Essa função recebe uma imagem RGB, transforma em HSV através da função "cvtColor()", divide-a em três canais H, S, V e chama a função "morphOps()" para retirar os ruídos dessa imagem.
	cvtColor(image_rgb, image_HSV, CV_BGR2HSV,3); 
	std::vector<cv::Mat> three_channels; //cria vetor e Divide imagem em 3 canais
	split(image_HSV, three_channels);
 	H = three_channels[0];
	S = three_channels[1];
	V = three_channels[2];
	morphOps(H);
	morphOps(S);
	morphOps(V);	
	//namedWindow("HSV Image"); //Define a janela
	imshow("HSV Image", image_HSV); //Mostra a imagem	
}

void CriaTrackbar(){//Cria barras que permitem o ajuste manual(em tempo real) dos valores mínimos e máximos dos parâmetros H, S e V.
	namedWindow("Thresholded", CV_WINDOW_AUTOSIZE); //Cria uma nova janela
	cvCreateTrackbar("H_min", "Thresholded", &H_min, 255); //Hue (0 - 255)
  	cvCreateTrackbar("H_max", "Thresholded", &H_max, 255); //Hue (0 - 255)
  	cvCreateTrackbar("S_min", "Thresholded", &S_min, 255); //Saturation (0 - 255)
  	cvCreateTrackbar("S_max", "Thresholded", &S_max, 255); //Saturation (0 - 255)
  	cvCreateTrackbar("V_min", "Thresholded", &V_min, 255); //Value (0 - 255)
  	cvCreateTrackbar("V_max", "Thresholded", &V_max, 255); //Value (0 - 255)
}


char* itoa(int value, char* result, int base){// Essa função foi utilizada para escrever uma frase pré-determinada em uma imagem. 
	if(base < 2 || base > 36){ 
		*result = '\0'; 
		return result; 
	} 
	char* ptr = result, *ptr1 = result, tmp_char;
	int tmp_value;
	do{
		tmp_value = value;
		value /= base;
		*ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
	}while (value);
	if (tmp_value < 0) *ptr++ = '-'; 
		*ptr-- = '\0';
	while(ptr1 < ptr){
		tmp_char = *ptr;
		*ptr--= *ptr1;
		*ptr1++ = tmp_char;
	}
	return result;
}

void Laranja(){
	Mat binary;  	    
	inRange(image_HSV, Scalar(0,202,108), Scalar(255,255, 255), binary);  //Conseguindo a imagem binária
	imshow("Binary",binary);   
	int i;  
	vector< vector<Point> > contours;  
	findContours(binary, contours, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE); //Encontra os contornos 
	vector<double> areas(contours.size());    
	for(i = 0; i < contours.size(); i++){  //Encontra a maior área de contorno  
		areas[i] = contourArea(Mat(contours[i])); 
	}   
	double max;  
	Point maxPosition;  
	minMaxLoc(Mat(areas),0,&max,0,&maxPosition);  	 
	drawContours(binary, contours, maxPosition.y, Scalar(255), CV_FILLED);  //Desenha o maior contorno
	//imshow("LargestContour",binary);   
	Rect r;  
	if(contours.size() >= 1){  
		r = boundingRect(contours[maxPosition.y]);  
		rectangle(image_rgb, r.tl(),r.br(), CV_RGB(255, 0, 0), 3, 8, 0); //Desenha um retângulo sobre a área com mair contorno
	}  
	center.x = r.x + (r.width/2);//Obtém o centro da área detectada
	center.y= r.y + (r.height/2);  
	char x[15],y[6];  
	itoa(center.x,x,10);//Escreve na imagem o valor das coordenadas centro    
	itoa(center.y,y,10);  
	strcat(x,",");  
	putText(image_rgb, strcat(x,y), center, FONT_HERSHEY_COMPLEX_SMALL, 0.8, cvScalar(255,0,0), 1, CV_AA);
	string textDireita = "Bolinha na direita !";
	string textEsquerda = "Bolinha na esquerda !";
	string textCentro = "Bolinha no centro !";
	int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;
	double fontScale = 1;
	int thickness = 3; 
	cv::Point textOrg(10, 130);

	if(center.x < 265)//Caso o objeto de interesse esteja a esquerda da tela, ou seja, em um pixel inferior a 265, então escreverá na tela "Bolinha na esquerda !"
	cv::putText(image_rgb, textEsquerda, textOrg, fontFace, fontScale, Scalar::all(255), thickness,8);

	else if(center.x > 365)//Caso o objeto de interesse esteja a direita da tela, ou seja, em um pixel superior a 365, então escreverá na tela "Bolinha na direita !"
	cv::putText(image_rgb, textDireita, textOrg, fontFace, fontScale, Scalar::all(255), thickness,8);

	else if(center.x >= 265 && center.x <= 365)//Caso o objeto de interesse esteja no meio  da tela, ou seja, em um pixel inferior a 365 e superior a 265, então escreverá na tela "Bolinha no centro!"
	cv::putText(image_rgb, textCentro, textOrg, fontFace, fontScale, Scalar::all(255), thickness,8);

	imshow("Final",image_rgb);
}

int ReadDepthData(unsigned int height_pos, unsigned int width_pos, sensor_msgs::ImageConstPtr depth_image) //Como o kinect é RGB-D, também podemos obter a profundidade da imagem, ou seja, pode-se determinar quão distante da câmera um objeto está. Com tal finalidade, essa função "ReadDepthData" irá receber como parâmetro a imagem de profundidade e retornar a distância em milimetros que o objeto está da câmera.
{
    if ((height_pos >= depth_image->height) || (width_pos >= depth_image->width))
        return -1;
    int index = (height_pos*depth_image->step) + (width_pos*(depth_image->step/depth_image->width));
    // If data is 4 byte floats (rectified depth image)
    if ((depth_image->step/depth_image->width) == 4) {
        U_FloatConvert depth_data;
        int i, endian_check = 1;
        // If big endian
        if ((depth_image->is_bigendian && (*(char*)&endian_check != 1)) ||  // Both big endian
           ((!depth_image->is_bigendian) && (*(char*)&endian_check == 1))) { // Both lil endian
            for (i = 0; i < 4; i++)
                depth_data.byte_data[i] = depth_image->data[index + i];
            // Make sure data is valid (check if NaN)
            if (depth_data.float_data == depth_data.float_data){
		ROS_INFO("Depth: %d", int(depth_data.float_data*1000));
                return int(depth_data.float_data*1000);
	    }  
          return -1;  // If depth data invalid
        }
        // else, one little endian, one big endian
        for (i = 0; i < 4; i++) 
            depth_data.byte_data[i] = depth_image->data[3 + index - i];
        // Make sure data is valid (check if NaN)
        if (depth_data.float_data == depth_data.float_data){
	    ROS_INFO("Depth: %d", int(depth_data.float_data*1000));
            return int(depth_data.float_data*1000);
	}
        return -1;  // If depth data invalid
    }
    // Otherwise, data is 2 byte integers (raw depth image)
   int temp_val;
   // If big endian
   if (depth_image->is_bigendian)
       temp_val = (depth_image->data[index] << 8) + depth_image->data[index + 1];
   // If little endian
   else
       temp_val = depth_image->data[index] + (depth_image->data[index + 1] << 8);
   // Make sure data is valid (check if NaN)
   if (temp_val == temp_val){
	ROS_INFO("Depth: %d", temp_val);
       return temp_val;
	}
   return -1;  // If depth data invalid
}

void imageCallback(const sensor_msgs::ImageConstPtr& image){  //Essa função é chamada toda vez que uma nova imagem for publicada
	cv_bridge::CvImageConstPtr cv_ptr;// "cv_bridge" é usado para converter imagens no ROS para imagens no OpenCV, cujo formato é do tipo "cv::Mat".
	try{
		cv_ptr = cv_bridge::toCvShare(image, "bgr8");
	} 
	catch(cv_bridge::Exception& e){
		ROS_ERROR("cv_bridge exception: %s", e.what());
		return;
	} 	
	image_rgb = cv_ptr->image;//Iguala "image_rgb" às imagens que estão sendo obtidas na câmera(cv_ptr->image).
	//namedWindow("Original Image"); //Define a janela
	//imshow("Original Image", image_rgb); //Mostra a imagem
	cv::waitKey(3);
	RGBtoHSV();
	Laranja();
}

void imageCallback2(const sensor_msgs::ImageConstPtr& image){//Essa função é chamada toda vez que uma nova imagem de profundidade for publicada	
depth = ReadDepthData(center.y, center.x, image); // Width = 640, Height = 480
    ROS_INFO("Distancia %d", depth);
}

int main(int argc, char **argv){
/*
A função ros::init() recebe os argumentos argc (argument count) e argv(argument values), usados para passar argumento via linha de comando, e o terceiro argumento é o nome do nó.
*/
        ros::init(argc, argv, "image_processor");

        ros::NodeHandle nh;//Inicializa o nó

	CriaTrackbar(); // Esta função deve ficar fora do loop sempre!

	image_transport::ImageTransport it(nh); 
 
   	cv::namedWindow(WINDOW, CV_WINDOW_AUTOSIZE);//Define a janela

     	image_transport::Subscriber sub = it.subscribe("rgb/image_raw", 1, imageCallback); //"image_transport subscribers" são usados como "ros::Subscriber", mas são mais especializados em receber imagens. 

	image_transport::Subscriber sub1 = it.subscribe("/depth/image_raw", 1, imageCallback2);

/*
A função advertise() irá publicar uma mensagem de um tipo especificado no arquivo "Num.msg" (int16, float, etc) no tópico "topico", e 1000 é o tamanho da fila de mensagens, usada para a publicação das mensagens.
*/
	pub2 = nh.advertise<beginner_tutorials::Num>("topico", 1000);

	ros::Rate loop_rate(10);//Essa função é um timer, e nesse caso mantém o loop em uma frequência de 10Hz para contar o tempo gasto dentro deste.

	while (ros::ok()){// Essa função retorná "false" apenas quando o nó for encerrado

		  beginner_tutorials::Num msg;//Cria uma variável "msg" que é do tipo especificado no arquivo "Num.msg"
		  msg.data = center.x;
		  msg.dist = depth;//A mensagem "msg" guarda duas informações. "msg.data" é a coordenada X que o objeto de interesse possui no momento e "msg.dist" é a distância que ele está da câmera" 		  
		  
		 // ROS_INFO("Publica coordenada:  [ %d ]!", msg.data);
		 // ROS_INFO("Publica distancia da tela: [%d] ", msg.dist);
		  pub2.publish(msg);//Publica todos os dados contidos na mensagem "msg" no tópico chamado "topico".
		  ros::spinOnce();//Essa função não retornará enquanto o nó não for encerrado, ou seja, enquanto a função ros::shutdown() não for chamada ou apertar Ctrl-C no terminal.
		  loop_rate.sleep();
	}

  	cv::destroyWindow(WINDOW);//Fecha a janela 
        pub = it.advertise("rgb/image_processed", 1);
        ros::spin();
}
