/////////////////////////////////////////////     image callback     ////////////////////////////////////////////////////

void imageCallback(const sensor_msgs::ImageConstPtr& image){  //This function is called everytime a new image is published
	cv_bridge::CvImageConstPtr cv_ptr;
	try{
		cv_ptr = cv_bridge::toCvShare(image, "bgr8");
	} 
	catch(cv_bridge::Exception& e){
		ROS_ERROR("cv_bridge exception: %s", e.what());
		return;
	}
	if(aux != 0)  // Caso não seja a primeira imagem pegada da câmera, copia-se a imagem prévia
		image_rgb_previous = image_rgb.clone();
	image_rgb = cv_ptr->image;
	if(aux == 0)  // Caso seja a primeira imagem pegada da câmera, não há imagem prévia. Logo, se copia a imagem atual
		image_rgb_previous = image_rgb.clone();
	//opticalFlow(image_rgb_previous, image_rgb);
	
	namedWindow("Image Prévia"); 
	//imshow("Image Prévia", image_rgb_previous); 	


	creatTrackbarYellow();
	//creatTrackbarRed();
	filter();
        Contorno();
	findYellowBlocks(image_rgb, squaresYellow);
    	drawSquares(image_yellow, squaresYellow);
	draw();
	//int depth = ReadDepthData(RefPointYellowDepth.y, RefPointYellowDepth.x, image); // Width = 640, Height = 480		
	depth += ReadDepthData(260, 160, image); // Width = 640, Height = 480
	aux++;	
	if(aux%20 == 0){       
		ROS_INFO("Depth: %d", depth/20);
		aux = 0;
		depth = 0;
	}	
	//findRedBlocks(image_rgb, squaresRed);
	//drawSquares(image_red, squaresRed);
	namedWindow("Image Yellow"); 
	imshow("Image Yellow", image_yellow); 
	//namedWindow("Image Red"); 
	//imshow("Image Red", image_red); 
	// findContours(image_rgb);
	cv::waitKey(3);
}

/////////////////////////////////////////////// main ////////////////////////////////////////////////////////


int main(int argc, char **argv){

	ros::init(argc, argv, "image_processor");
        ros::NodeHandle nh;
	image_transport::ImageTransport it(nh); 
     	image_transport::Subscriber sub = it.subscribe("/camera/rgb/image_raw", 1, imageCallback); //********

	ros::Rate loop_rate(10);

	while (ros::ok()){
		  ros::spinOnce();
		  loop_rate.sleep();
	}

        pub = it.advertise("rgb/image_processed", 1);
        ros::spin();
   	ROS_INFO("tutorialROSOpenCV::main.cpp::No error.");
	return 0;
}

